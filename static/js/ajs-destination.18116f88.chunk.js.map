{"version":3,"file":"static/js/ajs-destination.18116f88.chunk.js","mappings":"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","sources":["../node_modules/@segment/analytics-core/src/validation/helpers.ts","../node_modules/@segment/analytics-next/src/lib/is-plan-event-enabled.ts","../node_modules/@segment/analytics-next/src/plugins/ajs-destination/loader.ts","../node_modules/@segment/analytics-next/src/plugins/ajs-destination/index.ts","../node_modules/@segment/analytics-next/src/plugins/ajs-destination/utils.ts"],"sourcesContent":["import { CoreSegmentEvent } from '../events'\n\nexport function isString(obj: unknown): obj is string {\n  return typeof obj === 'string'\n}\n\nexport function isNumber(obj: unknown): obj is number {\n  return typeof obj === 'number'\n}\n\nexport function isFunction(obj: unknown): obj is Function {\n  return typeof obj === 'function'\n}\n\nexport function isPlainObject(\n  obj: unknown\n): obj is Record<string | symbol | number, any> {\n  return (\n    Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() === 'object'\n  )\n}\n\nexport function hasUser(event: CoreSegmentEvent): boolean {\n  const id =\n    event.userId ?? event.anonymousId ?? event.groupId ?? event.previousId\n  return isString(id)\n}\n","import { PlanEvent, TrackPlan } from '../core/events/interfaces'\n\n/**\n * Determines whether a track event is allowed to be sent based on the\n * user's tracking plan.\n * If the user does not have a tracking plan or the event is allowed based\n * on the tracking plan configuration, returns true.\n */\nexport function isPlanEventEnabled(\n  plan: TrackPlan | undefined,\n  planEvent: PlanEvent | undefined\n): boolean {\n  // Always prioritize the event's `enabled` status\n  if (typeof planEvent?.enabled === 'boolean') {\n    return planEvent.enabled\n  }\n\n  // Assume absence of a tracking plan means events are enabled\n  return plan?.__default?.enabled ?? true\n}\n","import { Analytics } from '../../core/analytics'\nimport { LegacyIntegrationConfiguration } from '../../browser'\nimport { getNextIntegrationsURL } from '../../lib/parse-cdn'\nimport { Context } from '../../core/context'\nimport { User } from '../../core/user'\nimport { loadScript, unloadScript } from '../../lib/load-script'\nimport {\n  LegacyIntegration,\n  ClassicIntegrationBuilder,\n  ClassicIntegrationSource,\n} from './types'\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase().replace('.', '').replace(/\\s+/g, '-')\n}\n\nfunction obfuscatePathName(pathName: string, obfuscate = false): string | void {\n  return obfuscate ? btoa(pathName).replace(/=/g, '') : undefined\n}\n\nexport function resolveIntegrationNameFromSource(\n  integrationSource: ClassicIntegrationSource\n) {\n  return (\n    'Integration' in integrationSource\n      ? integrationSource.Integration\n      : integrationSource\n  ).prototype.name\n}\n\nfunction recordLoadMetrics(fullPath: string, ctx: Context, name: string): void {\n  try {\n    const [metric] =\n      window?.performance?.getEntriesByName(fullPath, 'resource') ?? []\n    // we assume everything that took under 100ms is cached\n    metric &&\n      ctx.stats.gauge('legacy_destination_time', Math.round(metric.duration), [\n        name,\n        ...(metric.duration < 100 ? ['cached'] : []),\n      ])\n  } catch (_) {\n    // not available\n  }\n}\n\nexport function buildIntegration(\n  integrationSource: ClassicIntegrationSource,\n  integrationSettings: { [key: string]: any },\n  analyticsInstance: Analytics\n): LegacyIntegration {\n  let integrationCtr: ClassicIntegrationBuilder\n  // GA and Appcues use a different interface to instantiating integrations\n  if ('Integration' in integrationSource) {\n    const analyticsStub = {\n      user: (): User => analyticsInstance.user(),\n      addIntegration: (): void => {},\n    }\n\n    integrationSource(analyticsStub)\n    integrationCtr = integrationSource.Integration\n  } else {\n    integrationCtr = integrationSource\n  }\n\n  const integration = new integrationCtr(integrationSettings)\n  integration.analytics = analyticsInstance\n  return integration\n}\n\nexport async function loadIntegration(\n  ctx: Context,\n  name: string,\n  version: string,\n  obfuscate?: boolean\n): Promise<ClassicIntegrationSource> {\n  const pathName = normalizeName(name)\n  const obfuscatedPathName = obfuscatePathName(pathName, obfuscate)\n  const path = getNextIntegrationsURL()\n\n  const fullPath = `${path}/integrations/${\n    obfuscatedPathName ?? pathName\n  }/${version}/${obfuscatedPathName ?? pathName}.dynamic.js.gz`\n\n  try {\n    await loadScript(fullPath)\n    recordLoadMetrics(fullPath, ctx, name)\n  } catch (err) {\n    ctx.stats.gauge('legacy_destination_time', -1, [`plugin:${name}`, `failed`])\n    throw err\n  }\n\n  // @ts-ignore\n  const deps: string[] = window[`${pathName}Deps`]\n  await Promise.all(deps.map((dep) => loadScript(path + dep + '.gz')))\n\n  // @ts-ignore\n  window[`${pathName}Loader`]()\n\n  return window[\n    // @ts-ignore\n    `${pathName}Integration`\n  ] as ClassicIntegrationSource\n}\n\nexport async function unloadIntegration(\n  name: string,\n  version: string,\n  obfuscate?: boolean\n): Promise<void> {\n  const path = getNextIntegrationsURL()\n  const pathName = normalizeName(name)\n  const obfuscatedPathName = obfuscatePathName(name, obfuscate)\n\n  const fullPath = `${path}/integrations/${\n    obfuscatedPathName ?? pathName\n  }/${version}/${obfuscatedPathName ?? pathName}.dynamic.js.gz`\n\n  return unloadScript(fullPath)\n}\n\nexport function resolveVersion(\n  settings?: LegacyIntegrationConfiguration\n): string {\n  return (\n    settings?.versionSettings?.override ??\n    settings?.versionSettings?.version ??\n    'latest'\n  )\n}\n","import { Integrations, JSONObject } from '../../core/events'\nimport { Alias, Facade, Group, Identify, Page, Track } from '@segment/facade'\nimport { Analytics, InitOptions } from '../../core/analytics'\nimport { LegacySettings } from '../../browser'\nimport { isOffline, isOnline } from '../../core/connection'\nimport { Context, ContextCancelation } from '../../core/context'\nimport { isServer } from '../../core/environment'\nimport { DestinationPlugin, Plugin } from '../../core/plugin'\nimport { attempt } from '@segment/analytics-core'\nimport { isPlanEventEnabled } from '../../lib/is-plan-event-enabled'\nimport { mergedOptions } from '../../lib/merged-options'\nimport { pWhile } from '../../lib/p-while'\nimport { PriorityQueue } from '../../lib/priority-queue'\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted'\nimport {\n  applyDestinationMiddleware,\n  DestinationMiddlewareFunction,\n} from '../middleware'\nimport {\n  buildIntegration,\n  loadIntegration,\n  resolveIntegrationNameFromSource,\n  resolveVersion,\n  unloadIntegration,\n} from './loader'\nimport { LegacyIntegration, ClassicIntegrationSource } from './types'\nimport { isPlainObject } from '@segment/analytics-core'\nimport {\n  isDisabledIntegration as shouldSkipIntegration,\n  isInstallableIntegration,\n} from './utils'\n\nexport type ClassType<T> = new (...args: unknown[]) => T\n\nasync function flushQueue(\n  xt: Plugin,\n  queue: PriorityQueue<Context>\n): Promise<PriorityQueue<Context>> {\n  const failedQueue: Context[] = []\n\n  if (isOffline()) {\n    return queue\n  }\n\n  await pWhile(\n    () => queue.length > 0 && isOnline(),\n    async () => {\n      const ctx = queue.pop()\n      if (!ctx) {\n        return\n      }\n\n      const result = await attempt(ctx, xt)\n      const success = result instanceof Context\n      if (!success) {\n        failedQueue.push(ctx)\n      }\n    }\n  )\n\n  // re-add failed tasks\n  failedQueue.map((failed) => queue.pushWithBackoff(failed))\n  return queue\n}\n\nexport class LegacyDestination implements DestinationPlugin {\n  name: string\n  version: string\n  settings: JSONObject\n  options: InitOptions = {}\n  type: Plugin['type'] = 'destination'\n  middleware: DestinationMiddlewareFunction[] = []\n\n  private _ready = false\n  private _initialized = false\n  private onReady: Promise<unknown> | undefined\n  private onInitialize: Promise<unknown> | undefined\n  private disableAutoISOConversion: boolean\n\n  integrationSource?: ClassicIntegrationSource\n  integration: LegacyIntegration | undefined\n\n  buffer: PriorityQueue<Context>\n  flushing = false\n\n  constructor(\n    name: string,\n    version: string,\n    settings: JSONObject = {},\n    options: InitOptions,\n    integrationSource?: ClassicIntegrationSource\n  ) {\n    this.name = name\n    this.version = version\n    this.settings = { ...settings }\n    this.disableAutoISOConversion = options.disableAutoISOConversion || false\n    this.integrationSource = integrationSource\n\n    // AJS-Renderer sets an extraneous `type` setting that clobbers\n    // existing type defaults. We need to remove it if it's present\n    if (this.settings['type'] && this.settings['type'] === 'browser') {\n      delete this.settings['type']\n    }\n\n    this.options = options\n    this.buffer = options.disableClientPersistence\n      ? new PriorityQueue(4, [])\n      : new PersistedPriorityQueue(4, `dest-${name}`)\n\n    this.scheduleFlush()\n  }\n\n  isLoaded(): boolean {\n    return this._ready\n  }\n\n  ready(): Promise<unknown> {\n    return this.onReady ?? Promise.resolve()\n  }\n\n  async load(ctx: Context, analyticsInstance: Analytics): Promise<void> {\n    if (this._ready || this.onReady !== undefined) {\n      return\n    }\n\n    const integrationSource =\n      this.integrationSource ??\n      (await loadIntegration(\n        ctx,\n        this.name,\n        this.version,\n        this.options.obfuscate\n      ))\n\n    this.integration = buildIntegration(\n      integrationSource,\n      this.settings,\n      analyticsInstance\n    )\n\n    this.onReady = new Promise((resolve) => {\n      const onReadyFn = (): void => {\n        this._ready = true\n        resolve(true)\n      }\n\n      this.integration!.once('ready', onReadyFn)\n    })\n\n    this.onInitialize = new Promise((resolve) => {\n      const onInit = (): void => {\n        this._initialized = true\n        resolve(true)\n      }\n\n      this.integration!.on('initialize', onInit)\n    })\n\n    try {\n      ctx.stats.increment('analytics_js.integration.invoke', 1, [\n        `method:initialize`,\n        `integration_name:${this.name}`,\n      ])\n\n      this.integration.initialize()\n    } catch (error) {\n      ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\n        `method:initialize`,\n        `integration_name:${this.name}`,\n      ])\n\n      throw error\n    }\n  }\n\n  unload(_ctx: Context, _analyticsInstance: Analytics): Promise<void> {\n    return unloadIntegration(this.name, this.version, this.options.obfuscate)\n  }\n\n  addMiddleware(...fn: DestinationMiddlewareFunction[]): void {\n    this.middleware = this.middleware.concat(...fn)\n  }\n\n  shouldBuffer(ctx: Context): boolean {\n    return (\n      // page events can't be buffered because of destinations that automatically add page views\n      ctx.event.type !== 'page' &&\n      (isOffline() || this._ready === false || this._initialized === false)\n    )\n  }\n\n  private async send<T extends Facade>(\n    ctx: Context,\n    clz: ClassType<T>,\n    eventType: 'track' | 'identify' | 'page' | 'alias' | 'group'\n  ): Promise<Context> {\n    if (this.shouldBuffer(ctx)) {\n      this.buffer.push(ctx)\n      this.scheduleFlush()\n      return ctx\n    }\n\n    const plan = this.options?.plan?.track\n    const ev = ctx.event.event\n\n    if (plan && ev && this.name !== 'Segment.io') {\n      // events are always sent to segment (legacy behavior)\n      const planEvent = plan[ev]\n      if (!isPlanEventEnabled(plan, planEvent)) {\n        ctx.updateEvent('integrations', {\n          ...ctx.event.integrations,\n          All: false,\n          'Segment.io': true,\n        })\n        ctx.cancel(\n          new ContextCancelation({\n            retry: false,\n            reason: `Event ${ev} disabled for integration ${this.name} in tracking plan`,\n            type: 'Dropped by plan',\n          })\n        )\n        return ctx\n      } else {\n        ctx.updateEvent('integrations', {\n          ...ctx.event.integrations,\n          ...planEvent?.integrations,\n        })\n      }\n\n      if (planEvent?.enabled && planEvent?.integrations![this.name] === false) {\n        ctx.cancel(\n          new ContextCancelation({\n            retry: false,\n            reason: `Event ${ev} disabled for integration ${this.name} in tracking plan`,\n            type: 'Dropped by plan',\n          })\n        )\n        return ctx\n      }\n    }\n\n    const afterMiddleware = await applyDestinationMiddleware(\n      this.name,\n      ctx.event,\n      this.middleware\n    )\n\n    if (afterMiddleware === null) {\n      return ctx\n    }\n\n    const event = new clz(afterMiddleware, {\n      traverse: !this.disableAutoISOConversion,\n    })\n\n    ctx.stats.increment('analytics_js.integration.invoke', 1, [\n      `method:${eventType}`,\n      `integration_name:${this.name}`,\n    ])\n\n    try {\n      if (this.integration) {\n        await this.integration.invoke.call(this.integration, eventType, event)\n      }\n    } catch (err) {\n      ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\n        `method:${eventType}`,\n        `integration_name:${this.name}`,\n      ])\n      throw err\n    }\n\n    return ctx\n  }\n\n  async track(ctx: Context): Promise<Context> {\n    return this.send(ctx, Track as ClassType<Track>, 'track')\n  }\n\n  async page(ctx: Context): Promise<Context> {\n    if (this.integration?._assumesPageview && !this._initialized) {\n      this.integration.initialize()\n    }\n\n    return this.onInitialize!.then(() => {\n      return this.send(ctx, Page as ClassType<Page>, 'page')\n    })\n  }\n\n  async identify(ctx: Context): Promise<Context> {\n    return this.send(ctx, Identify as ClassType<Identify>, 'identify')\n  }\n\n  async alias(ctx: Context): Promise<Context> {\n    return this.send(ctx, Alias as ClassType<Alias>, 'alias')\n  }\n\n  async group(ctx: Context): Promise<Context> {\n    return this.send(ctx, Group as ClassType<Group>, 'group')\n  }\n\n  private scheduleFlush(): void {\n    if (this.flushing) {\n      return\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      this.flushing = true\n      this.buffer = await flushQueue(this, this.buffer)\n      this.flushing = false\n\n      if (this.buffer.todo > 0) {\n        this.scheduleFlush()\n      }\n    }, Math.random() * 5000)\n  }\n}\n\nexport function ajsDestinations(\n  settings: LegacySettings,\n  globalIntegrations: Integrations = {},\n  options: InitOptions = {},\n  routingMiddleware?: DestinationMiddlewareFunction,\n  legacyIntegrationSources?: ClassicIntegrationSource[]\n): LegacyDestination[] {\n  if (isServer()) {\n    return []\n  }\n\n  if (settings.plan) {\n    options = options ?? {}\n    options.plan = settings.plan\n  }\n\n  const routingRules = settings.middlewareSettings?.routingRules ?? []\n  const remoteIntegrationsConfig = settings.integrations\n  const localIntegrationsConfig = options.integrations\n  // merged remote CDN settings with user provided options\n  const integrationOptions = mergedOptions(settings, options ?? {}) as Record<\n    string,\n    JSONObject\n  >\n\n  const adhocIntegrationSources = legacyIntegrationSources?.reduce(\n    (acc, integrationSource) => ({\n      ...acc,\n      [resolveIntegrationNameFromSource(integrationSource)]: integrationSource,\n    }),\n    {} as Record<string, ClassicIntegrationSource>\n  )\n\n  const installableIntegrations = new Set([\n    // Remotely configured installable integrations\n    ...Object.keys(remoteIntegrationsConfig).filter((name) =>\n      isInstallableIntegration(name, remoteIntegrationsConfig[name])\n    ),\n\n    // Directly provided integration sources are only installable if settings for them are available\n    ...Object.keys(adhocIntegrationSources || {}).filter(\n      (name) =>\n        isPlainObject(remoteIntegrationsConfig[name]) ||\n        isPlainObject(localIntegrationsConfig?.[name])\n    ),\n  ])\n\n  return Array.from(installableIntegrations)\n    .filter((name) => !shouldSkipIntegration(name, globalIntegrations))\n    .map((name) => {\n      const integrationSettings = remoteIntegrationsConfig[name]\n      const version = resolveVersion(integrationSettings)\n      const destination = new LegacyDestination(\n        name,\n        version,\n        integrationOptions[name],\n        options,\n        adhocIntegrationSources?.[name]\n      )\n\n      const routing = routingRules.filter(\n        (rule) => rule.destinationName === name\n      )\n      if (routing.length > 0 && routingMiddleware) {\n        destination.addMiddleware(routingMiddleware)\n      }\n\n      return destination\n    })\n}\n","import { Integrations } from '@segment/analytics-core'\nimport { LegacyIntegrationConfiguration } from '../..'\n\nexport const isInstallableIntegration = (\n  name: string,\n  integrationSettings: LegacyIntegrationConfiguration\n) => {\n  const { type, bundlingStatus, versionSettings } = integrationSettings\n  // We use `!== 'unbundled'` (versus `=== 'bundled'`) to be inclusive of\n  // destinations without a defined value for `bundlingStatus`\n  const deviceMode =\n    bundlingStatus !== 'unbundled' &&\n    (type === 'browser' || versionSettings?.componentTypes?.includes('browser'))\n\n  // checking for iterable is a quick fix we need in place to prevent\n  // errors showing Iterable as a failed destiantion. Ideally, we should\n  // fix the Iterable metadata instead, but that's a longer process.\n  return !name.startsWith('Segment') && name !== 'Iterable' && deviceMode\n}\n\nexport const isDisabledIntegration = (\n  integrationName: string,\n  globalIntegrations: Integrations\n) => {\n  const allDisableAndNotDefined =\n    globalIntegrations.All === false &&\n    globalIntegrations[integrationName] === undefined\n\n  return (\n    globalIntegrations[integrationName] === false || allDisableAndNotDefined\n  )\n}\n"],"names":["isPlainObject","obj","Object","prototype","toString","call","slice","toLowerCase","isPlanEventEnabled","plan","planEvent","enabled","__default","_a","_b","normalizeName","name","replace","obfuscatePathName","pathName","obfuscate","btoa","undefined","loadIntegration","ctx","version","obfuscatedPathName","path","getNextIntegrationsURL","fullPath","concat","loadScript","metric","window","performance","getEntriesByName","stats","gauge","Math","round","duration","__spreadArray","_","recordLoadMetrics","err_1","deps","Promise","all","map","dep","flushQueue","xt","queue","failedQueue","isOffline","pWhile","length","isOnline","pop","attempt","result","Context","push","failed","pushWithBackoff","settings","options","integrationSource","type","middleware","_ready","_initialized","flushing","this","__assign","disableAutoISOConversion","buffer","disableClientPersistence","PriorityQueue","PersistedPriorityQueue","scheduleFlush","LegacyDestination","onReady","resolve","analyticsInstance","_c","integration","integrationSettings","integrationCtr","user","addIntegration","Integration","analytics","buildIntegration","_this","once","onInitialize","on","increment","initialize","error","_ctx","_analyticsInstance","unloadScript","unloadIntegration","fn","apply","event","clz","eventType","shouldBuffer","track","ev","updateEvent","integrations","All","cancel","ContextCancelation","retry","reason","applyDestinationMiddleware","afterMiddleware","traverse","invoke","send","Track","_assumesPageview","then","Page","Identify","Alias","Group","setTimeout","todo","random","ajsDestinations","globalIntegrations","routingMiddleware","legacyIntegrationSources","isServer","routingRules","middlewareSettings","remoteIntegrationsConfig","localIntegrationsConfig","integrationOptions","mergedOptions","adhocIntegrationSources","reduce","acc","resolveIntegrationNameFromSource","installableIntegrations","Set","keys","filter","bundlingStatus","versionSettings","deviceMode","componentTypes","includes","startsWith","isInstallableIntegration","Array","from","integrationName","allDisableAndNotDefined","shouldSkipIntegration","override","_d","resolveVersion","destination","rule","destinationName","addMiddleware"],"sourceRoot":""}